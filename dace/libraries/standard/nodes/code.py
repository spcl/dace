# Copyright 2019-2021 ETH Zurich and the DaCe authors. All rights reserved.
from copy import deepcopy
from dace import dtypes
from dace.data import Data
from dace.properties import Property
from dace.sdfg.nodes import Node, Tasklet, LibraryNode
import dace.library
from dace.memlet import Memlet
from dace.sdfg import SDFG, SDFGState
from dace.transformation.transformation import ExpandTransformation
from typing import Dict, Tuple


def _dataview(data: Data, memlet: Memlet) -> Data:
    """ Returns a data descriptor view of a data descriptor and a memlet. """
    result = deepcopy(data)
    result.shape = memlet.subset.size()
    return result


def _get_inputs_and_outputs(sdfg: SDFG, state: SDFGState, node: Node) -> Tuple[Dict[str, Data], Dict[str, Data]]:
    """ Returns two dictionaries that map from input/output connectors to data 
        descriptors. 
        
        :return: Tuple of (input memlet mapping, output memlet mapping).
    """
    inputs: Dict[str, Data] = {}
    for edge in state.in_edges(node):
        inputs[edge.dst_conn] = _dataview(sdfg.arrays[edge.data.data], edge.data)

    outputs: Dict[str, Data] = {}
    for edge in state.out_edges(node):
        outputs[edge.src_conn] = _dataview(sdfg.arrays[edge.data.data], edge.data)

    return inputs, outputs


@dace.library.node
class CodeLibraryNode(LibraryNode):
    """ A convenience interface for nodes to generate specific code given
        properties. """

    # Global properties
    implementations = {}
    default_implementation = None

    inputdict = Property(dtype=dict, default={})
    outputdict = Property(dtype=dict, default={})

    @property
    def has_side_effects(self) -> bool:
        # By default, assume code library nodes have side effects unless said otherwise
        return True

    def generate_code(self, inputs: Dict[str, Data], outputs: Dict[str, Data]) -> str:
        """ Method that is responsible for generating the code related to
            this node.

            :param inputs: A dictionary mapping input names (on node connectors)
                           to data descriptors based on incoming memlets.
            :param outputs: A dictionary mapping output names (on node connectors)
                           to data descriptors based on outgoing memlets.
            :return: A string representing C++ code to be injected instead
                     of this node.
            :note: This method must be overridden by subclasses.
        """
        raise NotImplementedError('Must be overridden by subclasses')

    def __init__(self, input_names, output_names, *args, name='Custom Code', **kwargs):
        # Store connector types, if given
        if isinstance(input_names, dict):
            self.inputdict = input_names
        else:
            self.inputdict = {k: None for k in set(input_names)}
        if isinstance(output_names, dict):
            self.outputdict = output_names
        else:
            self.outputdict = {k: None for k in set(output_names)}

        super().__init__(name, *args, inputs=set(input_names), outputs=set(output_names), **kwargs)


@dace.library.expansion
class Expansion(ExpandTransformation):
    environments = []

    @staticmethod
    def expansion(node: CodeLibraryNode, state: SDFGState, sdfg: SDFG):
        # Extract input and output array views (as generated by memlets)
        inputs, outputs = _get_inputs_and_outputs(sdfg, state, node)
        # Generate the appropriate code
        code = node.generate_code(inputs, outputs)
        # Replace this node with a C++ tasklet
        return Tasklet('custom_code', node.inputdict, node.outputdict, code, language=dtypes.Language.CPP)


CodeLibraryNode.register_implementation('default', Expansion)
CodeLibraryNode.default_implementation = 'default'
