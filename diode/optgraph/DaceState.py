""" State of DaCe program in DIODE. """
import os
import re
import sys
import copy
import dace
import tempfile
import traceback
from six import StringIO

from dace import types
from dace.transformation import optimizer
from dace.sdfg import SDFG
from dace.frontend.python import parser
from dace.frontend.python.parser import DaceProgram


class DaceState:
    """ This class abstracts away the DaCe implementation from the GUI, the 
        idea is that you pass in a string of DaCe code and this class will 
        compile the code, give you access to the SDFG and the generated code, 
        as well as the matching optimization patterns. 
    
        DaCe requires the code to be in a file (for code inspection), but 
        while the user types in the GUI we do not have the data available in a 
        file. Thus we create a temp directory and save it there. However, the 
        user might check for the filename in the code, thus we provide the 
        original file name in argv[0].
    """

    # TODO: rewrite this class to use in-memory code.

    def __init__(self,
                 dace_code,
                 fake_fname,
                 source_code=None,
                 sdfg=None,
                 headless=False):

        self.compiled = False
        self.dace_tmpfile = None
        self.dace_filename = os.path.basename(fake_fname)
        self.sdfg = sdfg  # This is the toplevel one
        self.sdfgs = []  # This is a collection of all the SDFGs
        self.generated_code = []
        self.generated_code_files = None
        self.matching_patterns = []
        self.headless = headless
        self.dace_code = dace_code
        self.source_code = source_code
        self.errors = [
        ]  # Any errors that arise from compilation are placed here to show
        # them once the sdfg is rendered

        self.has_multiple_eligible_sdfgs = False

        if self.sdfg is not None:
            self.compiled = True

            # Generate python stub to initialize inputs and load the SDFG
            self.dace_code = """
# THIS IS AN AUTOGENERATED LOADER FOR A SAVED SDFG

import dace
import numpy

{initializers}

sdfg = dace.SDFG.from_file("sdfg.out")
func = sdfg.compile()
func({args})

{prints}    """.format(
                initializers=self.get_arg_initializers(),
                args=", ".join([x + "=" + x for x in self.get_call_args()]),
                prints='\n'.join([
                    'print("{x} =", numpy.array2string({x}))'.format(x=x)
                    for x in self.get_call_args()
                ]))
            self.sdfgs = [('deserialized', self.sdfg)]

        tempdir = tempfile.mkdtemp()
        self.dace_tmpfile = os.path.join(tempdir, self.dace_filename)
        fh = open(self.dace_tmpfile, "w")
        fh.write(self.dace_code)
        fh.close()

        # Create SDFG unless we already have one
        if self.sdfg is None:
            saved_argv = sys.argv
            sys.argv = [self.dace_filename]
            gen_module = {}
            code = compile(self.dace_code, self.dace_tmpfile, 'exec')
            try:
                exec(code, gen_module)
            except Exception as ex:
                self.errors.append(ex)

            # Find dace programs
            self.sdfgs = [(name, parser.parse_from_function(obj))
                          for name, obj in gen_module.items()
                          if isinstance(obj, DaceProgram)]
            self.sdfgs += [(name, obj) for name, obj in gen_module.items()
                           if isinstance(obj, SDFG)]
            # TODO: detecting parents is broken, just take the first one for now
            self.sdfg = self.sdfgs[0][1]
            if len(self.sdfg) > 1:
                self.has_multiple_eligible_sdfgs = True

    def get_arg_initializers(self):
        sdfg = self.sdfg
        if sdfg is None:
            raise ValueError("Need an SDFG to produce initializers")
        data = set()
        for state in sdfg.nodes():
            data.update(
                set((n.data, n.desc(sdfg)) for n in state.nodes()
                    if isinstance(n, dace.graph.nodes.AccessNode)))

        sym_args = [k for k, _ in sdfg.undefined_symbols(False).items()]
        data_args = [d for d in data if not d[1].transient]

        initializer = ""
        for d in data_args:
            initializer += str(d[0]) + " = dace.ndarray([" + \
            ", ".join([str(x) for x in list(d[1].shape)]) + "], " + \
            "dtype=dace." + d[1].dtype.to_string() + ")\n"

        return initializer

    def get_call_args(self):
        sdfg = self.sdfg
        if sdfg is None:
            raise ValueError("Need an SDFG to produce call arguments")
        data = set()
        for state in sdfg.nodes():
            data.update(
                set((n.data, n.desc(sdfg)) for n in state.nodes()
                    if isinstance(n, dace.graph.nodes.AccessNode)))

        sym_args = [k for k, _ in sdfg.undefined_symbols(False).items()]
        data_args = [d for d in data if not d[1].transient]

        call_args = []
        for d in data_args:
            call_args.append(d[0])

        return call_args

    def compile(self):
        try:
            self.sdfg.validate()
            code = self.sdfg.generate_code()
            self.generated_code = code
            self.compiled = True
        # TODO: SDFG validation errors should be treated separately
        #except dace.sdfg.InvalidSDFGError:
        except:
            exstr = StringIO()
            formatted_lines = traceback.format_exc().splitlines()
            exstr.write("Compilation failed:\n%s\n\n" % formatted_lines[-1])
            traceback.print_exc(file=exstr)
            self.generated_code = exstr.getvalue()
            if self.headless == True:
                print("Codegen failed!\n" + str(self.generated_code))
                sys.exit(-1)

    def get_dace_generated_files(self):
        """ Writes the generated code to a temporary file and returns the file
            name. Compiles the code if not already compiled. """
        tempdir = tempfile.mkdtemp()
        self.generated_code_files = []

        for codeobj in self.generated_code:
            name = codeobj.name
            extension = codeobj.language
            gencodefile = os.path.join(tempdir, '%s.%s' % (name, extension))

            with open(gencodefile, "w") as fh:
                # Clear location indicators from code
                clean_code = re.sub(r'\s*////__DACE:.*', '', codeobj.code)
                fh.write(clean_code)

            self.generated_code_files.append(gencodefile)

        return self.generated_code_files

    def get_dace_tmpfile(self):
        """ Returns the current temporary path to the generated code files. """
        return self.dace_tmpfile

    def get_dace_fake_fname(self):
        """ Returns the original filename of the DaCe program, i.e., the name 
            of the file he stored to, before performing modifications in the 
            editor """
        return self.dace_filename

    def set_is_compiled(self, state):
        self.compiled = state

    def get_dace_code(self):
        return self.dace_code

    def get_generated_code(self):
        if self.compiled == False:
            self.compile()
        return self.generated_code

    def get_sdfg(self):
        if self.compiled == False:
            self.compile()
        return self.sdfgs[0][1]

    def set_sdfg(self, sdfg, name="Main SDFG"):
        self.sdfgs = [(name, sdfg)]
        self.sdfg = sdfg
        self.compiled = False
        if self.compiled == False:
            self.compile()

    def get_sdfgs(self):
        """ Returns the current set of SDFGs in the workspace.
            @rtype: Tuples of (name, SDFG).
        """
        if self.compiled == False:
            self.compile()
        return self.sdfgs
